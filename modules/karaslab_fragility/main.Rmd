---
title: "RAVE Fragility"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include = FALSE}
# This code block sets up the engine environment
# Please do not remove me
raveio::pipeline_setup_rmd("karaslab_fragility")
```

## Introduction

A RAVE pipeline markdown is an interactive notebook that can keep your notes, code blocks, and corresponding results together, generating reports in various formats such as `PDF`, `html`, `Word`, `PowerPoint`. 

The note parts are simply `markdown`s - the same as `jupyter notebook`, or github documentations. The code blocks support `R`, `python`, `c++`. When you hit the `Knit` button in this code editor panel, the r-markdown file will be compiled, generating reproducible documentation.

With carefully designed structures, this r-markdown file will automatically generate `RAVE` pipeline scripts during the compilation. The pipeline script can be used by `RAVE` to convert your pipeline into interactive dashboard application. (This feature is currently under development)

## "RAVE" Pipeline Code Block

A `RAVE` pipeline markdown code block starts with ` ```{rave ... `. The block label following `rave` informative description of the target. After the target, the following RAVE-specific parameters configures how the block should be treated:

* `language`: specifies the programming language used; choices are: `R`, `python`
* `export`: variable name to be exported that will be available to the rest chunks
* `depends`: indicates current block depends on variables generated from other blocks; this helps `RAVE` to build non-interactive pipeline scripts internally. For blocks written in `R`, the dependence can be automatically determined.

Other parameters are available at [this `rmarkdown` book](https://bookdown.org/yihui/rmarkdown/)

## An Example

In the rest of the documentation, let's import the subject power data, baseline, and plot the collapsed mean as image.

#### Step 1: Create `RAVE` subject's instances

Noting that all the items in the `settings.yaml` are available as variables.

```{rave load_subject, language = "R", export = "subject"}
library(raveio)
subject <- RAVESubject$new(
  project_name = project_name, 
  subject_code = subject_code,
  strict = TRUE
)
print(subject)

# List subject details
subject$epoch_names
subject$reference_names
subject$blocks
subject$electrodes

# Check if notch & wavelet has been applied on all electrodes
all(subject$notch_filtered)
```

With `export="subject"`, the subject variable will be registered for the following chunks to use. Be aware that all other variables created in this block will not be exposed.

#### Step 2: Initialize and load voltage data

Initialize the electrode instances and register the epoch, reference information

```{rave load_electrodes, language = "R", export = "loading_elec"}
loading_elec <- dipsaus::parse_svec(load_electrodes)
loading_elec <- subject$electrodes[subject$electrodes %in% loading_elec]
if(!length(loading_elec)) {
  stop("No valid electrode to load!")
}
```

Start to load voltage. Here also create cache to the `RAVE` cache directory.

```{rave load_voltage, language = "R", export = "repository"}
repository <- raveio::prepare_subject_voltage_with_epoch(
  subject = subject,
  electrodes = loading_elec,
  epoch_name = epoch_name,
  reference_name = reference_name,
  time_windows = epoch_time_window
)
```

#### Step 3: Find Adjacency Array

```{rave find_adjacency, language = "R", export = "A"}
A <- generate_adjacency_array(
  repository = repository,
  trial_num = trial_num,
  t_window = t_window,
  t_step = t_step,
  nlambda = nlambda
)
```


#### Step 4: Find Fragility Matrix

```{rave find_fragility, language = "R", export = "f_info"}
f_info <- generate_fragility_matrix(
  A = A,
  elec = repository$electrode_list,
  ncores = 4
)
```

#### Step 5: Visualize

```{rave plot_fragility_map, language = "R", export = "plot_fragility_map_timestamp"}

f_info$norm <- f_info$norm[as.character(loading_elec),]
  elecsort <- sort(as.numeric(attr(f_info$norm, "dimnames")[[1]])) # electrode indices sorted by ascending number
  fsort <- as.numeric(attr(sort(f_info$avg), "names")) # electrode indices sorted by descending fragility

  # if (sort_fmap == 'Electrode (ascending)') {
  #   elec_order <- elecsort
  # } else if (sort_fmap == 'Electrode (descending)') {
  #   elec_order <- rev(elecsort)
  # } else if (sort_fmap == 'Fragility (ascending)') {
  #   elec_order <- fsort
  # } else if (sort_fmap == 'Fragility (descending)') {
  #   elec_order <- rev(fsort)
  # }

  y <- rev(elecsort) # determine what order to display electrodes in

  f_info$norm <- f_info$norm[as.character(y),]
  x <- 1:dim(f_info$norm)[2]
  m <- t(f_info$norm)

  attr(m, 'xlab') = 'Time (s)'
  attr(m, 'ylab') = 'Electrode'
  attr(m, 'zlab') = 'Fragility'

  tp <- repository$voltage$dimnames$Time

  # for electrode label spacing on y axis
  yi = seq_along(y)
  if(length(y) > 10) {
    .seq = seq(1, length(y), length.out=10)
    y = y[.seq]
    yi = .seq
  }

  # map x axis from timewindows (x) to time (for mtext)
  xtime <- round(seq(tp[1], tp[length(tp)], length.out = 9), digits = 2)
  xi <- seq(1, length(x), length.out = 9)

  # map seizure onset from time (from slider input) to timewindows (for abline)
  secs <- seq(tp[1], tp[length(tp)])
  onset <- seq(1, length(x), length.out = length(secs))[match(sz_onset,secs)]

  plot_fragility_map_timestamp <- Sys.time()
  
  ravebuiltins:::draw_many_heat_maps(list(
    list(
      data = m,
      x = x,
      y = seq_along(elecsort),
      has_trials = TRUE,
      range = 0:1
    )
  ), axes = c(FALSE,FALSE), PANEL.LAST = ravebuiltins:::add_decorator(function(...) {
    abline(v = onset, lty = 2, lwd = 2)
    mtext(y, side=2, line=-1, at=yi, cex=(ravebuiltins:::rave_cex.lab*0.8), las=1)
    mtext(xtime, side=1, line=1, at=xi, cex=(ravebuiltins:::rave_cex.lab*0.8), las=1)
  }, ravebuiltins:::spectrogram_heatmap_decorator())
  )
```

## Build, Visualize, & Run

Please make sure the following code block is at the end of your pipeline file. This block will build the pipeline and generate a `make-karaslab_fragility.R` script with your pipeline markdown file. `RAVE` will use the generated pipeline script to execute the pipeline in the dashboard application, or in massive production mode.

```{r build, echo=FALSE, results='hide'}
build_pipeline(make_file = "make-karaslab_fragility.R")
```


Once the pipeline script `make-karaslab_fragility.R` is built, you can visualize and execute the pipeline without the need of re-knit this document. Notice we use `r` block instead of `rave`. (This is because the code blocks are not part of pipeline targets.)

```{r visualize, echo=FALSE}
Sys.setenv("RAVE_PIPELINE" = normalizePath("."))
try({
  raveio::pipeline_visualize()
}, silent = TRUE)
```


```{r execute}
Sys.setenv("RAVE_PIPELINE" = normalizePath("."))
raveio::pipeline_run(type = "vanilla")
raveio::pipeline_progress(method = 'details')
```






